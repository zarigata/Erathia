class_name Chunk
extends StaticBody3D

# Based on Mikola Lysenko's Surface Nets implementation
# https://github.com/mikolalysenko/isosurface

const CHUNK_SIZE = 16
const DATA_SIZE = 18  # Chunk + padding for seamless meshing

var noise: FastNoiseLite
var chunk_position: Vector3i
var biome_manager: BiomeManager
var density_data: PackedFloat32Array
var material_data: PackedByteArray
var decoration_points: Array[Vector3]
var terrain_material: Material = null

# Precomputed edge table - CRITICAL: edges 0,1,2 must be from corner 0 along X,Y,Z
# Generated by: for i in 0..7: for j in [1,2,4]: if i <= i^j: add edge(i, i^j)
# This ensures edge 0,1,2 are (0,1), (0,2), (0,4) - corner 0 along X,Y,Z axes
const CUBE_EDGES = [
	0, 1,  # Edge 0: corner 0 → corner 1 (along X)
	0, 2,  # Edge 1: corner 0 → corner 2 (along Y)
	0, 4,  # Edge 2: corner 0 → corner 4 (along Z)
	1, 3,  # Edge 3
	1, 5,  # Edge 4
	2, 3,  # Edge 5
	2, 6,  # Edge 6
	3, 7,  # Edge 7
	4, 5,  # Edge 8
	4, 6,  # Edge 9
	5, 7,  # Edge 10
	6, 7   # Edge 11
]

# Corner offsets for a unit cube
const CORNER_OFFSETS = [
	Vector3i(0, 0, 0), Vector3i(1, 0, 0), Vector3i(0, 1, 0), Vector3i(1, 1, 0),
	Vector3i(0, 0, 1), Vector3i(1, 0, 1), Vector3i(0, 1, 1), Vector3i(1, 1, 1)
]

var _is_initialized: bool = false

func _init(p_noise: FastNoiseLite, p_pos: Vector3i, p_biome_mgr: BiomeManager):
	noise = p_noise
	chunk_position = p_pos
	biome_manager = p_biome_mgr
	
	var mat_path = "res://_assets/shaders/terrain_material.tres"
	if ResourceLoader.exists(mat_path):
		terrain_material = load(mat_path)
	
	# Pre-allocate arrays with proper size
	var total_size: int = DATA_SIZE * DATA_SIZE * DATA_SIZE
	density_data = PackedFloat32Array()
	density_data.resize(total_size)
	density_data.fill(0.0)
	
	material_data = PackedByteArray()
	material_data.resize(total_size)
	material_data.fill(0)
	
	decoration_points = []
	_is_initialized = true

func schedule_mesh_update():
	WorkerThreadPool.add_task(_update_task)

func generate_chunk():
	WorkerThreadPool.add_task(_init_task)



func _init_task():
	if not _is_initialized:
		return
	_generate_data()
	_update_task()

func _update_task():
	if not _is_initialized:
		return
	var mesh_data = _generate_mesh_data()
	call_deferred("_apply_mesh", mesh_data)

func _deferred_mesh_update():
	# Run mesh generation on worker thread, apply on main thread
	WorkerThreadPool.add_task(_update_task)

func _generate_data():
	var idx = 0
	for z in range(DATA_SIZE):
		for y in range(DATA_SIZE):
			for x in range(DATA_SIZE):
				# Data index 0 = local position -1, etc.
				var local_pos = Vector3i(x - 1, y - 1, z - 1)
				var global_pos = (chunk_position * CHUNK_SIZE) + local_pos
				
				# Use BiomeManager for height if available
				var height: float
				if biome_manager:
					height = biome_manager.get_terrain_height(global_pos.x, global_pos.z)
				else:
					height = noise.get_noise_2d(global_pos.x, global_pos.z) * 50.0
				
				# Height-based density (positive = solid, negative = air)
				var d = height - global_pos.y
				density_data[idx] = d
				
				# Generate Material ID based on biome
				var mat_id = MiningSystem.MaterialID.STONE
				
				# Get biome for surface material
				var biome: BiomeDefinition = null
				if biome_manager:
					biome = biome_manager.get_biome_data(global_pos.x, global_pos.z)
				
				# Surface approximation (density close to 0)
				if d > -1.5 and d < 1.5:
					if biome:
						# Use biome-specific surface material
						if biome.biome_name == &"OCEAN":
							mat_id = MiningSystem.MaterialID.SAND
						elif biome.biome_name == &"BEACH":
							mat_id = MiningSystem.MaterialID.SAND
						elif biome.biome_name == &"DESERT":
							mat_id = MiningSystem.MaterialID.SAND
						elif biome.biome_name == &"TUNDRA":
							mat_id = MiningSystem.MaterialID.SNOW
						elif biome.biome_name == &"MOUNTAIN":
							mat_id = MiningSystem.MaterialID.STONE
						else:
							mat_id = MiningSystem.MaterialID.GRASS
					else:
						if global_pos.y < -2.0:
							mat_id = MiningSystem.MaterialID.SAND
						else:
							mat_id = MiningSystem.MaterialID.GRASS
					
					# Decoration chance for underwater
					if global_pos.y < -5.0 and randf() > 0.995:
						decoration_points.append(Vector3(x, y, z) - Vector3(1,1,1))
				elif d > -5.0 and d < -1.5:
					mat_id = MiningSystem.MaterialID.DIRT
				
				# Air check
				if d < 0:
					mat_id = MiningSystem.MaterialID.AIR
					
				material_data[idx] = mat_id
				idx += 1

func _get_density(x: int, y: int, z: int) -> float:
	return density_data[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]

func _get_material(x: int, y: int, z: int) -> int:
	return material_data[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]

func set_material_at(local_pos: Vector3i, mat_id: int):
	# Offset for padding
	var x = local_pos.x + 1
	var y = local_pos.y + 1
	var z = local_pos.z + 1
	
	if x >= 0 and x < DATA_SIZE and y >= 0 and y < DATA_SIZE and z >= 0 and z < DATA_SIZE:
		var idx = x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE
		material_data[idx] = mat_id
		schedule_mesh_update()

func _generate_mesh_data() -> ArrayMesh:
	var vertices: PackedVector3Array = PackedVector3Array()
	var normals: PackedVector3Array = PackedVector3Array()
	var indices: PackedInt32Array = PackedInt32Array()
	
	# Buffer to store vertex indices for each cell
	# We use a 3D index: buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]
	var buffer: PackedInt32Array = PackedInt32Array()
	buffer.resize(DATA_SIZE * DATA_SIZE * DATA_SIZE)
	buffer.fill(-1)
	
	# Step 1: Generate vertices for all cells that cross the isosurface
	for z in range(DATA_SIZE - 1):
		for y in range(DATA_SIZE - 1):
			for x in range(DATA_SIZE - 1):
				# Read 8 corner values and compute mask
				var mask = 0
				var grid: Array[float] = []
				for c in range(8):
					var co = CORNER_OFFSETS[c]
					var d = _get_density(x + co.x, y + co.y, z + co.z)
					grid.append(d)
					if d < 0:  # Air (negative = outside)
						mask |= (1 << c)
				
				# Skip cells entirely inside or outside
				if mask == 0 or mask == 255:
					continue
				
				# Compute the edge mask (which edges cross the surface)
				var edge_mask = 0
				for i in range(12):
					var e0 = CUBE_EDGES[i * 2]
					var e1 = CUBE_EDGES[i * 2 + 1]
					var a = (mask & (1 << e0)) != 0
					var b = (mask & (1 << e1)) != 0
					if a != b:
						edge_mask |= (1 << i)
				
				# Compute average intersection point
				var v = Vector3.ZERO
				var e_count = 0
				
				for i in range(12):
					if not (edge_mask & (1 << i)):
						continue
					
					e_count += 1
					var e0 = CUBE_EDGES[i * 2]
					var e1 = CUBE_EDGES[i * 2 + 1]
					var g0 = grid[e0]
					var g1 = grid[e1]
					var t = g0 / (g0 - g1) if abs(g0 - g1) > 1e-6 else 0.5
					
					# Interpolate position
					var p0 = Vector3(CORNER_OFFSETS[e0])
					var p1 = Vector3(CORNER_OFFSETS[e1])
					v += p0.lerp(p1, t)
				
				if e_count == 0:
					continue
				
				v /= float(e_count)
				
				# Convert to chunk-local coordinates (offset by -1 for padding)
				var local_pos = Vector3(x, y, z) + v - Vector3(1, 1, 1)
				
				# Compute analytical normal
				var global_pos = Vector3(chunk_position * CHUNK_SIZE) + local_pos
				var normal = _calculate_normal(global_pos.x, global_pos.z)
				
				# Store vertex and record its index
				buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE] = vertices.size()
				vertices.append(local_pos)
				normals.append(normal)
				
				# Step 2: Create faces for edges crossing the surface
				# Only check the first 3 edges (along X, Y, Z axes from corner 0)
				for axis in range(3):
					if not (edge_mask & (1 << axis)):
						continue
					
					# Get the two orthogonal axes
					var u = (axis + 1) % 3
					var w = (axis + 2) % 3
					
					# Check boundaries
					var pos = Vector3i(x, y, z)
					if pos[u] == 0 or pos[w] == 0:
						continue
					
					# Get the 4 cell indices for this quad
					var du = Vector3i.ZERO
					du[u] = 1
					var dw = Vector3i.ZERO
					dw[w] = 1
					
					var i0 = buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]
					var i1 = buffer[(x - du.x) + (y - du.y) * DATA_SIZE + (z - du.z) * DATA_SIZE * DATA_SIZE]
					var i2 = buffer[(x - dw.x) + (y - dw.y) * DATA_SIZE + (z - dw.z) * DATA_SIZE * DATA_SIZE]
					var i3 = buffer[(x - du.x - dw.x) + (y - du.y - dw.y) * DATA_SIZE + (z - du.z - dw.z) * DATA_SIZE * DATA_SIZE]
					
					# Skip if any vertex is missing
					if i0 < 0 or i1 < 0 or i2 < 0 or i3 < 0:
						continue
					
					# Key insight from mikolalysenko: flip based on corner 0's sign
					if mask & 1:
						# Corner 0 is inside (air in our convention where air is negative)
						indices.append(i0); indices.append(i1); indices.append(i2)
						indices.append(i2); indices.append(i1); indices.append(i3)
					else:
						# Corner 0 is outside (solid)
						indices.append(i0); indices.append(i2); indices.append(i1)
						indices.append(i1); indices.append(i2); indices.append(i3)
	
	if vertices.size() == 0 or indices.size() == 0:
		return null
	
	# Build mesh
	var arrays = []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = vertices
	arrays[Mesh.ARRAY_NORMAL] = normals
	arrays[Mesh.ARRAY_INDEX] = indices
	
	var mesh = ArrayMesh.new()
	mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	
	return mesh

func _apply_mesh(array_mesh: ArrayMesh):
	if not array_mesh:
		return
	
	# Remove old children immediately (not queue_free which is deferred)
	for child in get_children():
		remove_child(child)
		child.queue_free()
	
	var mesh_instance = MeshInstance3D.new()
	mesh_instance.mesh = array_mesh
	if terrain_material:
		mesh_instance.material_override = terrain_material
	
	var collision_shape = CollisionShape3D.new()
	collision_shape.shape = array_mesh.create_trimesh_shape()
	
	add_child(mesh_instance)
	add_child(collision_shape)
	
	# Apply decorations (disabled until UnderwaterDecorator is implemented)
	# for p in decoration_points:
	# 	if randf() > 0.5:
	# 		UnderwaterDecorator.spawn_starfish(self, p)
	# 	else:
	# 		UnderwaterDecorator.spawn_seaweed(self, p)
	
	# Clear points so we don't respawn on next mesh update if we don't regenerate data
	# But wait, if we only mesh update, we don't regenerate data... 
	# Actually decoration_points is filled in _generate_data. 
	# If we just smooth terrain (modify density), we call _update_task which calls _generate_mesh_data.
	# We lose decorations if we modify terrain? 
	# Yes, properly we should persists them or re-evaluate. 
	# For now, simplistic approach: Clear them to avoid duplicates if we somehow re-run safely.
	# Actually, if we Modify terrain, we don't re-run _generate_data, so points remain.
	# So we might respawn duplicates if we don't clear? 
	# But _apply_mesh clears children: `for child in get_children(): child.queue_free()`.
	# So we are safe to re-spawn from the list.
	pass

func _calculate_normal(gx: float, gz: float) -> Vector3:
	var e = 0.1
	var h0 = noise.get_noise_2d(gx, gz)
	var hx = noise.get_noise_2d(gx + e, gz)
	var hz = noise.get_noise_2d(gx, gz + e)
	
	var dx = (hx - h0) / e * 50.0
	var dz = (hz - h0) / e * 50.0
	
	return Vector3(-dx, 1.0, -dz).normalized()

func modify_sphere(center_local: Vector3, radius: float, value: float):
	var center_data = center_local + Vector3(1, 1, 1)
	
	var r_int = int(ceil(radius)) + 1
	var min_x = maxi(0, int(center_data.x) - r_int)
	var max_x = mini(DATA_SIZE - 1, int(center_data.x) + r_int)
	var min_y = maxi(0, int(center_data.y) - r_int)
	var max_y = mini(DATA_SIZE - 1, int(center_data.y) + r_int)
	var min_z = maxi(0, int(center_data.z) - r_int)
	var max_z = mini(DATA_SIZE - 1, int(center_data.z) + r_int)
	
	var radius_sq = radius * radius
	var modified = false
	var max_idx = DATA_SIZE * DATA_SIZE * DATA_SIZE - 1
	
	for z in range(min_z, max_z + 1):
		for y in range(min_y, max_y + 1):
			for x in range(min_x, max_x + 1):
				var corner_pos = Vector3(x, y, z)
				var dist_sq = corner_pos.distance_squared_to(center_data)
				
				if dist_sq <= radius_sq:
					var idx = x + (y * DATA_SIZE) + (z * DATA_SIZE * DATA_SIZE)
					if idx >= 0 and idx <= max_idx:
						var old_val = density_data[idx]
						density_data[idx] += value
						if abs(old_val - density_data[idx]) > 0.01:
							modified = true
	
	if modified:
		# Update mesh on main thread to avoid threading issues
		call_deferred("_deferred_mesh_update")
