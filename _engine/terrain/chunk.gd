class_name Chunk
extends StaticBody3D

# Based on Mikola Lysenko's Surface Nets implementation
# https://github.com/mikolalysenko/isosurface

const CHUNK_SIZE = 16
const DATA_SIZE = 18  # Chunk + padding for seamless meshing

var noise: FastNoiseLite
var chunk_position: Vector3i
var biome_manager: BiomeManager
var density_data: PackedFloat32Array
var terrain_material: Material = null

# Precomputed edge table - CRITICAL: edges 0,1,2 must be from corner 0 along X,Y,Z
# Generated by: for i in 0..7: for j in [1,2,4]: if i <= i^j: add edge(i, i^j)
# This ensures edge 0,1,2 are (0,1), (0,2), (0,4) - corner 0 along X,Y,Z axes
const CUBE_EDGES = [
	0, 1,  # Edge 0: corner 0 → corner 1 (along X)
	0, 2,  # Edge 1: corner 0 → corner 2 (along Y)
	0, 4,  # Edge 2: corner 0 → corner 4 (along Z)
	1, 3,  # Edge 3
	1, 5,  # Edge 4
	2, 3,  # Edge 5
	2, 6,  # Edge 6
	3, 7,  # Edge 7
	4, 5,  # Edge 8
	4, 6,  # Edge 9
	5, 7,  # Edge 10
	6, 7   # Edge 11
]

# Corner offsets for a unit cube
const CORNER_OFFSETS = [
	Vector3i(0, 0, 0), Vector3i(1, 0, 0), Vector3i(0, 1, 0), Vector3i(1, 1, 0),
	Vector3i(0, 0, 1), Vector3i(1, 0, 1), Vector3i(0, 1, 1), Vector3i(1, 1, 1)
]

func _init(p_noise: FastNoiseLite, p_pos: Vector3i, p_biome_mgr: BiomeManager):
	noise = p_noise
	chunk_position = p_pos
	biome_manager = p_biome_mgr
	
	var mat_path = "res://_assets/shaders/terrain_material.tres"
	if ResourceLoader.exists(mat_path):
		terrain_material = load(mat_path)
	
	density_data = PackedFloat32Array()
	density_data.resize(DATA_SIZE * DATA_SIZE * DATA_SIZE)

func generate_chunk():
	WorkerThreadPool.add_task(_init_task)

func _init_task():
	_generate_data()
	_update_task()

func _update_task():
	var mesh_data = _generate_mesh_data()
	call_deferred("_apply_mesh", mesh_data)

func _generate_data():
	var idx = 0
	for z in range(DATA_SIZE):
		for y in range(DATA_SIZE):
			for x in range(DATA_SIZE):
				# Data index 0 = local position -1, etc.
				var local_pos = Vector3i(x - 1, y - 1, z - 1)
				var global_pos = (chunk_position * CHUNK_SIZE) + local_pos
				
				# Height-based density (positive = solid, negative = air)
				var height = noise.get_noise_2d(global_pos.x, global_pos.z) * 50.0
				var d = height - global_pos.y
				
				density_data[idx] = d
				idx += 1

func _get_density(x: int, y: int, z: int) -> float:
	return density_data[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]

func _generate_mesh_data() -> ArrayMesh:
	var vertices: PackedVector3Array = PackedVector3Array()
	var normals: PackedVector3Array = PackedVector3Array()
	var indices: PackedInt32Array = PackedInt32Array()
	
	# Buffer to store vertex indices for each cell
	# We use a 3D index: buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]
	var buffer: PackedInt32Array = PackedInt32Array()
	buffer.resize(DATA_SIZE * DATA_SIZE * DATA_SIZE)
	buffer.fill(-1)
	
	# Step 1: Generate vertices for all cells that cross the isosurface
	for z in range(DATA_SIZE - 1):
		for y in range(DATA_SIZE - 1):
			for x in range(DATA_SIZE - 1):
				# Read 8 corner values and compute mask
				var mask = 0
				var grid: Array[float] = []
				for c in range(8):
					var co = CORNER_OFFSETS[c]
					var d = _get_density(x + co.x, y + co.y, z + co.z)
					grid.append(d)
					if d < 0:  # Air (negative = outside)
						mask |= (1 << c)
				
				# Skip cells entirely inside or outside
				if mask == 0 or mask == 255:
					continue
				
				# Compute the edge mask (which edges cross the surface)
				var edge_mask = 0
				for i in range(12):
					var e0 = CUBE_EDGES[i * 2]
					var e1 = CUBE_EDGES[i * 2 + 1]
					var a = (mask & (1 << e0)) != 0
					var b = (mask & (1 << e1)) != 0
					if a != b:
						edge_mask |= (1 << i)
				
				# Compute average intersection point
				var v = Vector3.ZERO
				var e_count = 0
				
				for i in range(12):
					if not (edge_mask & (1 << i)):
						continue
					
					e_count += 1
					var e0 = CUBE_EDGES[i * 2]
					var e1 = CUBE_EDGES[i * 2 + 1]
					var g0 = grid[e0]
					var g1 = grid[e1]
					var t = g0 / (g0 - g1) if abs(g0 - g1) > 1e-6 else 0.5
					
					# Interpolate position
					var p0 = Vector3(CORNER_OFFSETS[e0])
					var p1 = Vector3(CORNER_OFFSETS[e1])
					v += p0.lerp(p1, t)
				
				if e_count == 0:
					continue
				
				v /= float(e_count)
				
				# Convert to chunk-local coordinates (offset by -1 for padding)
				var local_pos = Vector3(x, y, z) + v - Vector3(1, 1, 1)
				
				# Compute analytical normal
				var global_pos = Vector3(chunk_position * CHUNK_SIZE) + local_pos
				var normal = _calculate_normal(global_pos.x, global_pos.z)
				
				# Store vertex and record its index
				buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE] = vertices.size()
				vertices.append(local_pos)
				normals.append(normal)
				
				# Step 2: Create faces for edges crossing the surface
				# Only check the first 3 edges (along X, Y, Z axes from corner 0)
				for axis in range(3):
					if not (edge_mask & (1 << axis)):
						continue
					
					# Get the two orthogonal axes
					var u = (axis + 1) % 3
					var w = (axis + 2) % 3
					
					# Check boundaries
					var pos = Vector3i(x, y, z)
					if pos[u] == 0 or pos[w] == 0:
						continue
					
					# Get the 4 cell indices for this quad
					var du = Vector3i.ZERO
					du[u] = 1
					var dw = Vector3i.ZERO
					dw[w] = 1
					
					var i0 = buffer[x + y * DATA_SIZE + z * DATA_SIZE * DATA_SIZE]
					var i1 = buffer[(x - du.x) + (y - du.y) * DATA_SIZE + (z - du.z) * DATA_SIZE * DATA_SIZE]
					var i2 = buffer[(x - dw.x) + (y - dw.y) * DATA_SIZE + (z - dw.z) * DATA_SIZE * DATA_SIZE]
					var i3 = buffer[(x - du.x - dw.x) + (y - du.y - dw.y) * DATA_SIZE + (z - du.z - dw.z) * DATA_SIZE * DATA_SIZE]
					
					# Skip if any vertex is missing
					if i0 < 0 or i1 < 0 or i2 < 0 or i3 < 0:
						continue
					
					# Key insight from mikolalysenko: flip based on corner 0's sign
					if mask & 1:
						# Corner 0 is inside (air in our convention where air is negative)
						indices.append(i0); indices.append(i1); indices.append(i2)
						indices.append(i2); indices.append(i1); indices.append(i3)
					else:
						# Corner 0 is outside (solid)
						indices.append(i0); indices.append(i2); indices.append(i1)
						indices.append(i1); indices.append(i2); indices.append(i3)
	
	if vertices.size() == 0 or indices.size() == 0:
		return null
	
	# Build mesh
	var arrays = []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = vertices
	arrays[Mesh.ARRAY_NORMAL] = normals
	arrays[Mesh.ARRAY_INDEX] = indices
	
	var mesh = ArrayMesh.new()
	mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	
	return mesh

func _apply_mesh(array_mesh: ArrayMesh):
	if not array_mesh:
		return
	
	var mesh_instance = MeshInstance3D.new()
	mesh_instance.mesh = array_mesh
	if terrain_material:
		mesh_instance.material_override = terrain_material
	
	var collision_shape = CollisionShape3D.new()
	collision_shape.shape = array_mesh.create_trimesh_shape()
	
	for child in get_children():
		child.queue_free()
	add_child(mesh_instance)
	add_child(collision_shape)

func _calculate_normal(gx: float, gz: float) -> Vector3:
	var e = 0.1
	var h0 = noise.get_noise_2d(gx, gz)
	var hx = noise.get_noise_2d(gx + e, gz)
	var hz = noise.get_noise_2d(gx, gz + e)
	
	var dx = (hx - h0) / e * 50.0
	var dz = (hz - h0) / e * 50.0
	
	return Vector3(-dx, 1.0, -dz).normalized()

func modify_sphere(center_local: Vector3, radius: float, value: float):
	var center_data = center_local + Vector3(1, 1, 1)
	
	var r_int = ceil(radius) + 1
	var min_box = (center_data - Vector3(r_int, r_int, r_int)).floor()
	var max_box = (center_data + Vector3(r_int, r_int, r_int)).ceil()
	
	var radius_sq = radius * radius
	var modified = false
	
	for z in range(max(0, min_box.z), min(DATA_SIZE, max_box.z)):
		for y in range(max(0, min_box.y), min(DATA_SIZE, max_box.y)):
			for x in range(max(0, min_box.x), min(DATA_SIZE, max_box.x)):
				var corner_pos = Vector3(x, y, z)
				var dist_sq = corner_pos.distance_squared_to(center_data)
				
				if dist_sq <= radius_sq:
					var idx = x + (y * DATA_SIZE) + (z * DATA_SIZE * DATA_SIZE)
					density_data[idx] += value
					modified = true
	
	if modified:
		WorkerThreadPool.add_task(_update_task)
